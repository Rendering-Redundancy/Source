<html>

<head>
    <style>
        canvas {
            padding: 5px;
            border-width: 2px;
            border-style: solid;
            border-color: dimgray;
        }
    </style>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
</head>

<body>
    <input type="button" value="Prev" onclick="prev()">
    <select id="paint_index"></select>
    <input type="button" value="Next" onclick="next()">

    <br>
    <br>

    <canvas id="content"></canvas>

    <script>
        const { ipcRenderer } = require('electron');
        const fs = require('fs');

        const canvas = document.getElementById('content');
        const context = canvas.getContext('2d');
        const paintIndex = document.getElementById('paint_index');

        let count;

        ipcRenderer.send('asynchronous-message', {
            name: "START"
        });

        ipcRenderer.on('asynchronous-reply', (event, arg) => {
            // console.log(arg);
            switch (arg.name) {
                case "START":
                    count = arg.value.count;
                    canvas.width = arg.value.maxWidth;
                    canvas.height = arg.value.maxHeight;

                    for (var i = 0; i <= count; i++) {
                        option = document.createElement('option');
                        option.text = i;
                        option.value = i;
                        paintIndex.add(option);
                    }
                    break;
                case "CONTENT":
                    drawMethod(arg.method);
                    break;
            }
        });

        function prev() {
            index = parseInt(document.getElementById('paint_index').value);
            if (index === 0) return;
            else {
                context.clearRect(0, 0, canvas.width, canvas.height);
                document.getElementById('paint_index').value = index - 1;
                ipcRenderer.send('asynchronous-message', {
                    name: "CONTENT",
                    index: index
                });
            }
        }

        function next() {
            var index = parseInt(document.getElementById('paint_index').value);
            if (index === count) return;
            else {
                context.clearRect(0, 0, canvas.width, canvas.height);
                document.getElementById('paint_index').value = index + 1;
                ipcRenderer.send('asynchronous-message', {
                    name: "CONTENT",
                    index: index
                });
            }
        }

        function ARGB2RGBA(color) {
            a = parseInt(color.substring(1, 3), 16) / 255;
            r = parseInt(color.substring(3, 5), 16);
            g = parseInt(color.substring(5, 7), 16);
            b = parseInt(color.substring(7, 9), 16);
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function drawMethod(m) {
            switch (m.type) {
                case "Rect":
                    if (m.style === 'Fill') {
                        context.fillStyle = ARGB2RGBA(m.color);
                        context.fillRect(m.region.left, m.region.top,
                            m.region.right - m.region.left,
                            m.region.bottom - m.region.top);
                    } else {
                        context.strokeStyle = ARGB2RGBA(m.color);
                        context.lineWidth = m.stroke[0];
                        context.lineCap = m.stroke[1].toLowerCase()
                        context.lineJoin = m.stroke[2].toLowerCase()
                        context.miterLimit = m.stroke[3]
                        context.strokeRect(m.region.left,
                            m.region.top,
                            m.region.right - m.region.left,
                            m.region.bottom - m.region.top);
                    }
                    break;
                case "RRect":
                    // Simplification: set radius as a constant value.
                    context.beginPath();
                    context.moveTo(m.region.left + 5, m.region.top);
                    context.lineTo(m.region.right - 5, m.region.top);
                    context.arcTo(m.region.right, m.region.top, m.region.right, m.region.top + 5, 5);
                    context.lineTo(m.region.right, m.region.bottom - 5);
                    context.arcTo(m.region.right, m.region.bottom, m.region.right - 5, m.region.bottom, 5);
                    context.lineTo(m.region.left + 5, m.region.bottom);
                    context.arcTo(m.region.left, m.region.bottom, m.region.left, m.region.bottom - 5, 5);
                    context.lineTo(m.region.left, m.region.top + 5);
                    context.arcTo(m.region.left, m.region.top, m.region.left + 5, m.region.top, 5);
                    context.closePath();

                    if (m.style === "Fill") {
                        context.fillStyle = ARGB2RGBA(m.color);
                        context.fill();
                    } else {
                        context.strokeStyle = ARGB2RGBA(m.color);
                        context.lineWidth = m.stroke[0];
                        context.lineCap = m.stroke[1].toLowerCase();
                        context.lineJoin = m.stroke[2].toLowerCase();
                        context.miterLimit = m.stroke[3];
                        context.stroke();
                    }
                    break;
                case "Path":
                    context.strokeStyle = ARGB2RGBA(m.color);
                    context.lineWidth = 1;
                    context.setLineDash([8, 8]);
                    context.strokeRect(m.region.left,
                        m.region.top,
                        m.region.right - m.region.left,
                        m.region.bottom - m.region.top);
                    break;
                case "Image":
                    // Display image on the canvas with given source.
                    var img = new Image();
                    img.onload = function () {
                        context.drawImage(img, m.region.left, m.region.top, m.region.right - m.region.left, m.region.bottom - m.region.top);
                    }
                    img.src = m.source;
                    break;
                case "Text":
                    // Point.{x,y} is better than Region.{left, top}.
                    context.fillStyle = ARGB2RGBA(m.color);
                    context.font = `${m.fontSize} ${m.fontFamily}`;
                    context.fillText(m.value, m.point.x, m.point.y);
                    break;
            }
        }
    </script>
</body>

</html>